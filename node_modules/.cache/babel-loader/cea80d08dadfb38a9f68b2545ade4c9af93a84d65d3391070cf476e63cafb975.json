{"ast":null,"code":"'use strict';\n\nconst fs = require('../fs');\nconst path = require('path');\nconst {\n  mkdirs\n} = require('../mkdirs');\nconst {\n  pathExists\n} = require('../path-exists');\nconst {\n  utimesMillis\n} = require('../util/utimes');\nconst stat = require('../util/stat');\nasync function copy(src, dest, opts = {}) {\n  if (typeof opts === 'function') {\n    opts = {\n      filter: opts\n    };\n  }\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    process.emitWarning('Using the preserveTimestamps option in 32-bit node is not recommended;\\n\\n' + '\\tsee https://github.com/jprichardson/node-fs-extra/issues/269', 'Warning', 'fs-extra-WARN0001');\n  }\n  const {\n    srcStat,\n    destStat\n  } = await stat.checkPaths(src, dest, 'copy', opts);\n  await stat.checkParentPaths(src, srcStat, dest, 'copy');\n  const include = await runFilter(src, dest, opts);\n  if (!include) return;\n\n  // check if the parent of dest exists, and create it if it doesn't exist\n  const destParent = path.dirname(dest);\n  const dirExists = await pathExists(destParent);\n  if (!dirExists) {\n    await mkdirs(destParent);\n  }\n  await getStatsAndPerformCopy(destStat, src, dest, opts);\n}\nasync function runFilter(src, dest, opts) {\n  if (!opts.filter) return true;\n  return opts.filter(src, dest);\n}\nasync function getStatsAndPerformCopy(destStat, src, dest, opts) {\n  const statFn = opts.dereference ? fs.stat : fs.lstat;\n  const srcStat = await statFn(src);\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts);\n  if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts);\n  if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);\n  if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`);\n  if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`);\n  throw new Error(`Unknown file: ${src}`);\n}\nasync function onFile(srcStat, destStat, src, dest, opts) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts);\n  if (opts.overwrite) {\n    await fs.unlink(dest);\n    return copyFile(srcStat, src, dest, opts);\n  }\n  if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`);\n  }\n}\nasync function copyFile(srcStat, src, dest, opts) {\n  await fs.copyFile(src, dest);\n  if (opts.preserveTimestamps) {\n    // Make sure the file is writable before setting the timestamp\n    // otherwise open fails with EPERM when invoked with 'r+'\n    // (through utimes call)\n    if (fileIsNotWritable(srcStat.mode)) {\n      await makeFileWritable(dest, srcStat.mode);\n    }\n\n    // Set timestamps and mode correspondingly\n\n    // Note that The initial srcStat.atime cannot be trusted\n    // because it is modified by the read(2) system call\n    // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n    const updatedSrcStat = await fs.stat(src);\n    await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime);\n  }\n  return fs.chmod(dest, srcStat.mode);\n}\nfunction fileIsNotWritable(srcMode) {\n  return (srcMode & 0o200) === 0;\n}\nfunction makeFileWritable(dest, srcMode) {\n  return fs.chmod(dest, srcMode | 0o200);\n}\nasync function onDir(srcStat, destStat, src, dest, opts) {\n  // the dest directory might not exist, create it\n  if (!destStat) {\n    await fs.mkdir(dest);\n  }\n  const promises = [];\n\n  // loop through the files in the current directory to copy everything\n  for await (const item of await fs.opendir(src)) {\n    const srcItem = path.join(src, item.name);\n    const destItem = path.join(dest, item.name);\n    promises.push(runFilter(srcItem, destItem, opts).then(include => {\n      if (include) {\n        // only copy the item if it matches the filter function\n        return stat.checkPaths(srcItem, destItem, 'copy', opts).then(({\n          destStat\n        }) => {\n          // If the item is a copyable file, `getStatsAndPerformCopy` will copy it\n          // If the item is a directory, `getStatsAndPerformCopy` will call `onDir` recursively\n          return getStatsAndPerformCopy(destStat, srcItem, destItem, opts);\n        });\n      }\n    }));\n  }\n  await Promise.all(promises);\n  if (!destStat) {\n    await fs.chmod(dest, srcStat.mode);\n  }\n}\nasync function onLink(destStat, src, dest, opts) {\n  let resolvedSrc = await fs.readlink(src);\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc);\n  }\n  if (!destStat) {\n    return fs.symlink(resolvedSrc, dest);\n  }\n  let resolvedDest = null;\n  try {\n    resolvedDest = await fs.readlink(dest);\n  } catch (e) {\n    // dest exists and is a regular file or directory,\n    // Windows may throw UNKNOWN error. If dest already exists,\n    // fs throws error anyway, so no need to guard against it here.\n    if (e.code === 'EINVAL' || e.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest);\n    throw e;\n  }\n  if (opts.dereference) {\n    resolvedDest = path.resolve(process.cwd(), resolvedDest);\n  }\n  if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n    throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);\n  }\n\n  // do not copy if src is a subdir of dest since unlinking\n  // dest in this case would result in removing src contents\n  // and therefore a broken symlink would be created.\n  if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n    throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);\n  }\n\n  // copy the link\n  await fs.unlink(dest);\n  return fs.symlink(resolvedSrc, dest);\n}\nmodule.exports = copy;","map":{"version":3,"names":["fs","require","path","mkdirs","pathExists","utimesMillis","stat","copy","src","dest","opts","filter","clobber","overwrite","preserveTimestamps","process","arch","emitWarning","srcStat","destStat","checkPaths","checkParentPaths","include","runFilter","destParent","dirname","dirExists","getStatsAndPerformCopy","statFn","dereference","lstat","isDirectory","onDir","isFile","isCharacterDevice","isBlockDevice","onFile","isSymbolicLink","onLink","isSocket","Error","isFIFO","copyFile","unlink","errorOnExist","fileIsNotWritable","mode","makeFileWritable","updatedSrcStat","atime","mtime","chmod","srcMode","mkdir","promises","item","opendir","srcItem","join","name","destItem","push","then","Promise","all","resolvedSrc","readlink","resolve","cwd","symlink","resolvedDest","e","code","isSrcSubdir","module","exports"],"sources":["D:/alumni-directory/node_modules/@shadcn/ui/node_modules/fs-extra/lib/copy/copy.js"],"sourcesContent":["'use strict'\n\nconst fs = require('../fs')\nconst path = require('path')\nconst { mkdirs } = require('../mkdirs')\nconst { pathExists } = require('../path-exists')\nconst { utimesMillis } = require('../util/utimes')\nconst stat = require('../util/stat')\n\nasync function copy (src, dest, opts = {}) {\n  if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    process.emitWarning(\n      'Using the preserveTimestamps option in 32-bit node is not recommended;\\n\\n' +\n      '\\tsee https://github.com/jprichardson/node-fs-extra/issues/269',\n      'Warning', 'fs-extra-WARN0001'\n    )\n  }\n\n  const { srcStat, destStat } = await stat.checkPaths(src, dest, 'copy', opts)\n\n  await stat.checkParentPaths(src, srcStat, dest, 'copy')\n\n  const include = await runFilter(src, dest, opts)\n\n  if (!include) return\n\n  // check if the parent of dest exists, and create it if it doesn't exist\n  const destParent = path.dirname(dest)\n  const dirExists = await pathExists(destParent)\n  if (!dirExists) {\n    await mkdirs(destParent)\n  }\n\n  await getStatsAndPerformCopy(destStat, src, dest, opts)\n}\n\nasync function runFilter (src, dest, opts) {\n  if (!opts.filter) return true\n  return opts.filter(src, dest)\n}\n\nasync function getStatsAndPerformCopy (destStat, src, dest, opts) {\n  const statFn = opts.dereference ? fs.stat : fs.lstat\n  const srcStat = await statFn(src)\n\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)\n\n  if (\n    srcStat.isFile() ||\n    srcStat.isCharacterDevice() ||\n    srcStat.isBlockDevice()\n  ) return onFile(srcStat, destStat, src, dest, opts)\n\n  if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)\n  if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`)\n  if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`)\n  throw new Error(`Unknown file: ${src}`)\n}\n\nasync function onFile (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts)\n\n  if (opts.overwrite) {\n    await fs.unlink(dest)\n    return copyFile(srcStat, src, dest, opts)\n  }\n  if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`)\n  }\n}\n\nasync function copyFile (srcStat, src, dest, opts) {\n  await fs.copyFile(src, dest)\n  if (opts.preserveTimestamps) {\n    // Make sure the file is writable before setting the timestamp\n    // otherwise open fails with EPERM when invoked with 'r+'\n    // (through utimes call)\n    if (fileIsNotWritable(srcStat.mode)) {\n      await makeFileWritable(dest, srcStat.mode)\n    }\n\n    // Set timestamps and mode correspondingly\n\n    // Note that The initial srcStat.atime cannot be trusted\n    // because it is modified by the read(2) system call\n    // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n    const updatedSrcStat = await fs.stat(src)\n    await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime)\n  }\n\n  return fs.chmod(dest, srcStat.mode)\n}\n\nfunction fileIsNotWritable (srcMode) {\n  return (srcMode & 0o200) === 0\n}\n\nfunction makeFileWritable (dest, srcMode) {\n  return fs.chmod(dest, srcMode | 0o200)\n}\n\nasync function onDir (srcStat, destStat, src, dest, opts) {\n  // the dest directory might not exist, create it\n  if (!destStat) {\n    await fs.mkdir(dest)\n  }\n\n  const promises = []\n\n  // loop through the files in the current directory to copy everything\n  for await (const item of await fs.opendir(src)) {\n    const srcItem = path.join(src, item.name)\n    const destItem = path.join(dest, item.name)\n\n    promises.push(\n      runFilter(srcItem, destItem, opts).then(include => {\n        if (include) {\n          // only copy the item if it matches the filter function\n          return stat.checkPaths(srcItem, destItem, 'copy', opts).then(({ destStat }) => {\n            // If the item is a copyable file, `getStatsAndPerformCopy` will copy it\n            // If the item is a directory, `getStatsAndPerformCopy` will call `onDir` recursively\n            return getStatsAndPerformCopy(destStat, srcItem, destItem, opts)\n          })\n        }\n      })\n    )\n  }\n\n  await Promise.all(promises)\n\n  if (!destStat) {\n    await fs.chmod(dest, srcStat.mode)\n  }\n}\n\nasync function onLink (destStat, src, dest, opts) {\n  let resolvedSrc = await fs.readlink(src)\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n  }\n  if (!destStat) {\n    return fs.symlink(resolvedSrc, dest)\n  }\n\n  let resolvedDest = null\n  try {\n    resolvedDest = await fs.readlink(dest)\n  } catch (e) {\n    // dest exists and is a regular file or directory,\n    // Windows may throw UNKNOWN error. If dest already exists,\n    // fs throws error anyway, so no need to guard against it here.\n    if (e.code === 'EINVAL' || e.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest)\n    throw e\n  }\n  if (opts.dereference) {\n    resolvedDest = path.resolve(process.cwd(), resolvedDest)\n  }\n  if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n    throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)\n  }\n\n  // do not copy if src is a subdir of dest since unlinking\n  // dest in this case would result in removing src contents\n  // and therefore a broken symlink would be created.\n  if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n    throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)\n  }\n\n  // copy the link\n  await fs.unlink(dest)\n  return fs.symlink(resolvedSrc, dest)\n}\n\nmodule.exports = copy\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}